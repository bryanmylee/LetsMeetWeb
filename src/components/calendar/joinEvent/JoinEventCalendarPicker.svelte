<script>
  import dayjs from 'dayjs';

  import {
    getMergedIntervals,
    splitIntervalsOnMidnight,
  } from '../../../utils/intervals.js';
  import { newSelectionDurationPerDayInMs } from '../../../stores.js';
  import { getMultiDaySelection } from '../../../utils/selections.js';

  import CalendarBase from '../CalendarBase.svelte';
  import CalendarDayColumn from '../CalendarDayColumn.svelte';
  import JoinEventCalendarUnavailableColumnOverlay
      from './JoinEventCalendarUnavailableColumnOverlay.svelte';
  import JoinEventCalendarOtherUsersColumnOverlay
      from './JoinEventCalendarOtherUsersColumnOverlay.svelte';
  import JoinEventCalendarDefinedSelection
      from './JoinEventCalendarDefinedSelection.svelte';
  import JoinEventCalendarNewSelection
      from './JoinEventCalendarNewSelection.svelte';

  // User selections.
  export let selections = [];
  // Event details.
  export let eventIntervals = [];
  export let userIntervalsByUsername = {};

  let eventIntervalsSplitOnMidnight = [];
  $: eventIntervalsSplitOnMidnight = splitIntervalsOnMidnight(eventIntervals);

  // Intervals with combined usernames.
  let mergedIntervals = [];
  $: mergedIntervals
      = splitIntervalsOnMidnight(getMergedIntervals(userIntervalsByUsername));
  // The maximum number of usernames in all intervals.
  let maxUsernames = 0;
  $: maxUsernames = mergedIntervals.reduce((max, interval) => {
    const { length } = interval.usernames;
    return max >= length ? max : length;
  }, 0);

  let daysToShow = [];
  $: {
    daysToShow = eventIntervalsSplitOnMidnight.reduce((days, interval) => {
      const { length } = days;
      if (length === 0) return [ interval.start.startOf('day') ];
      if (days[length - 1].isSame(interval.start, 'day')) return days;
      return [ ...days, interval.start.startOf('day') ];
    }, []);
  }
  const hours = Array.from(Array(24).keys())
      .map((inc) => dayjs().startOf('day').add(inc, 'hour'));

  // The new selection being made.
  let newSelection = null;
  // The current selection split into different days.
  let newSelections = [];
    
  const MS_PER_MINUTE = 60000;
  $: {
    if (newSelection != null) {
      newSelections = getMultiDaySelection(newSelection);
      $newSelectionDurationPerDayInMs
          = newSelections[0].end - newSelections[0].start;
    } else {
      newSelections = [];
      $newSelectionDurationPerDayInMs = 15 * MS_PER_MINUTE;
    }
  }

  function startSelection(e) {
    const { datetime } = e.detail;
    newSelection = ({
      start: datetime,
      // datetime represents the start of the cell.
      // Add 15 minutes to account for the time in the last cell.
      end: datetime.add(15, 'minute'),
    });
  }

  function gridDrag(e) {
    const { datetime } = e.detail;
    // datetime represents the start of the cell.
    // Add 15 minutes to account for the time in the last cell.
    newSelection = ({ ...newSelection,
      end: datetime.add(15, 'minute'),
    });
  }

  function stopSelection() {
    if (!newSelection || !newSelection.start || !newSelection.end) return;
    selections = [
      ...selections,
      ...newSelections,
    ];
    newSelection = null;
  }
</script>

<CalendarBase>
  {#each daysToShow as day}
    <CalendarDayColumn {day} {hours}
      on:startSelection={startSelection}
      on:gridDrag={gridDrag}
      on:stopSelection={stopSelection}
    >
      <!-- Render unavailable intervals -->
      <JoinEventCalendarUnavailableColumnOverlay
        eventIntervals={eventIntervalsSplitOnMidnight.filter((interval) =>
            interval.start.isSame(day, 'day')
        )}
      />
      <!-- Render other user selections -->
      <JoinEventCalendarOtherUsersColumnOverlay
        mergedIntervals={mergedIntervals.filter((interval) =>
            interval.start.isSame(day, 'day')
        )}
        {maxUsernames}
      />
      <!-- Render current user selections -->
      {#each selections.filter((selection) =>
          selection.start.isSame(day, 'date')) as selection}
        <JoinEventCalendarDefinedSelection {...selection} />
      {/each}
      <!-- Render current user new selections -->
      {#each newSelections.filter((selection) =>
          selection.start.isSame(day, 'date')) as selection}
        <JoinEventCalendarNewSelection start={selection.start} />
      {/each}
    </CalendarDayColumn>
  {/each}
</CalendarBase>